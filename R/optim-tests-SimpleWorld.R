# Optimisation experiments
source("R/SimpleWorld.R")
library(microbenchmark)
library(ggplot2)

# Look at the set-up data
x0
cons
ind
ind_cat

# Creating the function to optimise
# Setting up the input data
# ind_cat <- rbind(ind_cat, ind_cat[1,]) # add extra rows - just for testing
# indu <- unique(ind_cat) # save only unique individuals - dplyr::distinct forgets row.names

umat_count <- function(x) {
  xp <- apply(x, 1, paste0, collapse = "") # "pasted" version of constraints
  freq <- table(xp) # frequency of occurence of each individual
  xu <- unique(x) # save only unique individuals
  rns <- as.integer(row.names(xu)) # save the row names of unique values of ind
  xpu <- xp[rns]
  o <- order(xpu, decreasing = TRUE) # the order of the output (to rectify table)
  cbind(xu, data.frame(ind_num = freq[o], rns = rns)) # outputs
}

umat <- umat_count(ind_cat) 
indu <- apply(umat[1:ncol(ind_cat)], 2, function(x) x * umat$ind_num)

sim <- colSums(indu * c(1.2,3.5,1.5,4.5)) # test it on approximate dataset
sim - cons[1,] # test the function works

fun <- function(par, ind_num, con){
  sim <- colSums(par * ind_num)
  ae <- abs(sim - con) # Absolute error per category
  sum(ae) # the Total Absolute Error (TAE)
}
par <- c(1.2,3.5,1.5,4.5)
fun(par, indu, cons[1,]) # Shows the function in action

# Test the function on the weights obtained by IPF
# fun(weights[rns,1], indu, cons[1,]) # the weights generated by ipfp result in a tae of 0, better than optim

ores <- optim(par = rep(1, nrow(indu)), fn = fun, gr = "CG", ind_num = indu, con = cons[1,])
ores$par
fun(ores$par, indu, cons[1,]) # check TAE is low
fw <- ores$par[rep(1:nrow(umat), times = umat$ind_num)] # final weights

umat[1:ncol(ind_cat)][rep(1:nrow(umat), umat$ind_num),] # we've returned full circle to the correct population

# Next stage: try optimising the fit using diferent algorithms and do tests!

optim_optim_CG <- function(){
  optim(par = rep(1, nrow(indu)), fn = fun, gr = "CG", ind_num = indu, con = cons[1,])
}

# GenSA test
library(GenSA) # the library to test
out <- GenSA(par = rep(1, nrow(indu)), fn = fun, lower = rep(0, nrow(indu)), upper = rep(10^5, nrow(indu)), control = list(maxit = 10), ind_num = indu, con = cons[1,])
out$value

# rgenoud 
library(rgenoud)
set.seed(2014)
out <- genoud(nvars = nrow(indu), fn = fun, ind_num = indu, con = cons[1,], control = list(maxit = 1000), data.type.int = TRUE, Domains = matrix(c(rep(0, nrow(indu)),rep(100000, nrow(indu))), ncol = 2))
out$par
fun(par = out$par, ind_num = indu, con = cons)
fun(par = c(2,2,1,6), ind_num = indu, con = cons)

opt_res <- data.frame(algorithm = NA,
  maxit = NA,
  fit = NA,
  time = NA)
i = 20 # default iteration number
set.seed(2014)
for(i in 1:5){
  tmp_res <- optim(par = rep(1, nrow(indu)), fn = fun, method = "Nelder-Mead", ind_num = indu, con = cons[1,], control = list(maxit = i))
  opt_res <- rbind(opt_res, c("optim_Nelder", i, tmp_res$value, NA))
  tmp_res <- optim(par = rep(1, nrow(indu)), fn = fun, method = "SANN", ind_num = indu, con = cons[1,], control = list(maxit = i * 100))
  opt_res <- rbind(opt_res, c("optim_SANN", i, tmp_res$value, NA))
  tmp_res <- optim(par = rep(1, nrow(indu)), fn = fun, method = "BFGS", ind_num = indu, con = cons[1,], control = list(maxit = i))
  opt_res <- rbind(opt_res, c("optim_BFGS", i, tmp_res$value, NA))
  tmp_res <- optim(par = rep(1, nrow(indu)), fn = fun, method = "CG", ind_num = indu, con = cons[1,], control = list(maxit = i))
  opt_res <- rbind(opt_res, c("optim_CG", i, tmp_res$value, NA))
  weights <- apply(cons, 1, function(x) ipfp(x, ind_catt, x0, maxit = i))
  tae <- sum(abs(colSums(weights[,1] * ind_cat) - cons[1,]))
  opt_res <- rbind(opt_res, c("ipf", i, tae, NA))
  tmp_res <- GenSA(par = rep(1, nrow(indu)), fn = fun, lower = rep(0, nrow(indu)), upper = rep(10^2, nrow(indu)), control = list(maxit = i), ind_num = indu, con = cons[1,])
  opt_res <- rbind(opt_res, c("GenSA", i, tmp_res$value, NA))
}

opt_res$fit <- as.numeric(opt_res$fit)
opt_res$maxit <- as.numeric(opt_res$maxit)

qplot(data = opt_res, maxit, fit, linetype = algorithm, geom="line") +
  ylab("Total Absolute Error") + xlab("Iterations") +
#   scale_color_brewer(palette = 2, type = "qual") + 
  theme_classic()
# ggsave("figures/optim-its.png")

# Regenerate results for timings plot
opt_res <- data.frame(algorithm = NA,
  maxit = NA,
  fit = NA,
  time = NA)
i = 20 # default iteration number
set.seed(2014)
for(i in 1:5){
  tmp_res <- optim(par = rep(1, nrow(indu)), fn = fun, method = "Nelder-Mead", ind_num = indu, con = cons[1,], control = list(maxit = i * 50))
  opt_res <- rbind(opt_res, c("optim_Nelder", i, tmp_res$value, NA))
  tmp_res <- optim(par = rep(1, nrow(indu)), fn = fun, method = "SANN", ind_num = indu, con = cons[1,], control = list(maxit = i))
  opt_res <- rbind(opt_res, c("optim_SANN", i * 100, tmp_res$value, NA))
  tmp_res <- optim(par = rep(1, nrow(indu)), fn = fun, method = "BFGS", ind_num = indu, con = cons[1,], control = list(maxit = i))
  opt_res <- rbind(opt_res, c("optim_BFGS", i, tmp_res$value, NA))
  tmp_res <- optim(par = rep(1, nrow(indu)), fn = fun, method = "CG", ind_num = indu, con = cons[1,], control = list(maxit = i))
  opt_res <- rbind(opt_res, c("optim_CG", i, tmp_res$value, NA))
  weights <- apply(cons, 1, function(x) ipfp(x, ind_catt, x0, maxit = i))
  tae <- sum(abs(colSums(weights[,1] * ind_cat) - cons[1,]))
  opt_res <- rbind(opt_res, c("ipf", i, tae, NA))
  tmp_res <- GenSA(par = rep(1, nrow(indu)), fn = fun, lower = rep(0, nrow(indu)), upper = rep(10^2, nrow(indu)), control = list(maxit = i), ind_num = indu, con = cons[1,])
  opt_res <- rbind(opt_res, c("GenSA", i, tmp_res$value, NA))
}

opt_res$fit <- as.numeric(opt_res$fit)
opt_res$maxit <- as.numeric(opt_res$maxit)

### Timings
mb <- NULL
for(i in 1:5){
  Nelder <- function(){optim(par = rep(1, nrow(indu)), fn = fun, method = "Nelder-Mead", ind_num = indu, con = cons[1,], control = list(maxit = i * 50))}
  SANN <- function(){optim(par = rep(1, nrow(indu)), fn = fun, method = "SANN", ind_num = indu, con = cons[1,], control = list(maxit = i * 1000))}
  BFGS <- function(){optim(par = rep(1, nrow(indu)), fn = fun, method = "BFGS", ind_num = indu, con = cons[1,], control = list(maxit = i))}
  CG <- function(){optim(par = rep(1, nrow(indu)), fn = fun, method = "CG", ind_num = indu, con = cons[1,], control = list(maxit = i))}
  IPF <- function(){weights <- apply(cons, 1, function(x) ipfp(x, ind_catt, x0, maxit = i^5 ))
  tae <- sum(abs(colSums(weights[,1] * ind_cat) - cons[1,]))}
  GENSA <- function(){GenSA(par = rep(1, nrow(indu)), fn = fun, lower = rep(0, nrow(indu)), upper = rep(10^2, nrow(indu)), control = list(maxit = i), ind_num = indu, con = cons[1,])}
  mb <- rbind(mb, print(microbenchmark(Nelder(), SANN(), BFGS(), CG(), IPF(), GENSA(), times = 10)))
}

opt_res$time <- c(NA, mb$median)
qplot(data = opt_res, time, fit, linetype = algorithm, geom="line") +
  ylab("Total Absolute Error") + xlab("Time (microseconds)") + scale_color_brewer(palette = 2, type = "qual") + theme_classic() + xlim(c(0, 10000))
# ggsave("figures/optim-time.png")
### Background

### Stack overflow - simplest form - representation of the above
# See http://stackoverflow.com/questions/26160079/fast-concise-way-to-generate-ordered-frequency-count-of-unique-matrix-rows